#include "/Engine/Public/Platform.ush"


Buffer<int> mapChunkSize;
Buffer<float> noiseScale;
Buffer<int> octaveCount;
Buffer<float> persistance;
Buffer<float> lacurnarity;
Buffer<float2> octaveOffsets;

// RWStructuredBuffer<float> noiseMap : register(u0);
// RWBuffer<float> noiseMap : register(u0);
RWBuffer<float> noiseMap;


static int Permutation[512] = 
	{
		63, 9, 212, 205, 31, 128, 72, 59, 137, 203, 195, 170, 181, 115, 165, 40, 116, 139, 175, 225, 132, 99, 222, 2, 41, 15, 197, 93, 169, 90, 228, 43, 221, 38, 206, 204, 73, 17, 97, 10, 96, 47, 32, 138, 136, 30, 219,
		78, 224, 13, 193, 88, 134, 211, 7, 112, 176, 19, 106, 83, 75, 217, 85, 0, 98, 140, 229, 80, 118, 151, 117, 251, 103, 242, 81, 238, 172, 82, 110, 4, 227, 77, 243, 46, 12, 189, 34, 188, 200, 161, 68, 76, 171, 194,
		57, 48, 247, 233, 51, 105, 5, 23, 42, 50, 216, 45, 239, 148, 249, 84, 70, 125, 108, 241, 62, 66, 64, 240, 173, 185, 250, 49, 6, 37, 26, 21, 244, 60, 223, 255, 16, 145, 27, 109, 58, 102, 142, 253, 120, 149, 160,
		124, 156, 79, 186, 135, 127, 14, 121, 22, 65, 54, 153, 91, 213, 174, 24, 252, 131, 192, 190, 202, 208, 35, 94, 231, 56, 95, 183, 163, 111, 147, 25, 67, 36, 92, 236, 71, 166, 1, 187, 100, 130, 143, 237, 178, 158,
		104, 184, 159, 177, 52, 214, 230, 119, 87, 114, 201, 179, 198, 3, 248, 182, 39, 11, 152, 196, 113, 20, 232, 69, 141, 207, 234, 53, 86, 180, 226, 74, 150, 218, 29, 133, 8, 44, 123, 28, 146, 89, 101, 154, 220, 126,
		155, 122, 210, 168, 254, 162, 129, 33, 18, 209, 61, 191, 199, 157, 245, 55, 164, 167, 215, 246, 144, 107, 235, 

		63, 9, 212, 205, 31, 128, 72, 59, 137, 203, 195, 170, 181, 115, 165, 40, 116, 139, 175, 225, 132, 99, 222, 2, 41, 15, 197, 93, 169, 90, 228, 43, 221, 38, 206, 204, 73, 17, 97, 10, 96, 47, 32, 138, 136, 30, 219,
		78, 224, 13, 193, 88, 134, 211, 7, 112, 176, 19, 106, 83, 75, 217, 85, 0, 98, 140, 229, 80, 118, 151, 117, 251, 103, 242, 81, 238, 172, 82, 110, 4, 227, 77, 243, 46, 12, 189, 34, 188, 200, 161, 68, 76, 171, 194,
		57, 48, 247, 233, 51, 105, 5, 23, 42, 50, 216, 45, 239, 148, 249, 84, 70, 125, 108, 241, 62, 66, 64, 240, 173, 185, 250, 49, 6, 37, 26, 21, 244, 60, 223, 255, 16, 145, 27, 109, 58, 102, 142, 253, 120, 149, 160,
		124, 156, 79, 186, 135, 127, 14, 121, 22, 65, 54, 153, 91, 213, 174, 24, 252, 131, 192, 190, 202, 208, 35, 94, 231, 56, 95, 183, 163, 111, 147, 25, 67, 36, 92, 236, 71, 166, 1, 187, 100, 130, 143, 237, 178, 158,
		104, 184, 159, 177, 52, 214, 230, 119, 87, 114, 201, 179, 198, 3, 248, 182, 39, 11, 152, 196, 113, 20, 232, 69, 141, 207, 234, 53, 86, 180, 226, 74, 150, 218, 29, 133, 8, 44, 123, 28, 146, 89, 101, 154, 220, 126,
		155, 122, 210, 168, 254, 162, 129, 33, 18, 209, 61, 191, 199, 157, 245, 55, 164, 167, 215, 246, 144, 107, 235
	};


float SmoothCurve(float x)
{
	return x * x * x * (x * (x * 6.0f - 15.0f) + 10.0f);
}

float Grad2(int Hash, float X, float Y)
{
	// corners and major axes (similar to the z=0 projection of the cube-edge-midpoint sampling from improved Perlin noise)
	switch (Hash & 7)
	{
	case 0: 
		return (float)X;
	case 1: 
		return (float)(X + Y);
	case 2: 
		return (float)Y;
	case 3: 
		return (float)((-1)*X + Y);
	case 4: 
		return (float)((-1)*X);
	case 5: 
		return (float)((-1)*X - Y);
	case 6: 
		return (float)((-1)*Y);
	case 7: 
		return (float)(X - Y);
	// can't happen
	default: 
		return 0.0f;
	}
}

float Lerp(float value1, float value2, float factor)
{

	return value1 * (1 - factor) + value2 * factor;
}

float InverseLerp(float minimum, float maximum, float value)
{
	return (value - minimum) / (maximum - minimum);
}

float PerlinNoise(float2 mapSample)
{
	float Xfl = floor(mapSample.x);		// LWC_TODO: Precision loss
	float Yfl = floor(mapSample.y);
	int Xi = (int)(Xfl) & 255;
	int Yi = (int)(Yfl) & 255;
	float X = (float)mapSample.x - Xfl;
	float Y = (float)mapSample.y - Yfl;
	float Xm1 = X - 1.0f;
	float Ym1 = Y - 1.0f;

	// const int* P = Permutation;
	int AA = Permutation[Xi] + Yi;
	int AB = AA + 1;
	int BA = Permutation[Xi + 1] + Yi;
	int BB = BA + 1;

	float U = SmoothCurve(X);
	float V = SmoothCurve(Y);

	// Note: Due to the choice of Grad2, this will be in the (-1,1) range with no additional scaling
	float lerp1 = Lerp(Grad2(Permutation[AA], X, Y), Grad2(Permutation[BA], Xm1, Y), U);
	float lerp2 = Lerp(Grad2(Permutation[AB], X, Ym1), Grad2(Permutation[BB], Xm1, Ym1), U);

	float finalLerp = Lerp(lerp1, lerp2, V);

	return finalLerp;
}





[numthreads(THREAD_COUNT_X, THREAD_COUNT_Y, THREAD_COUNT_Z)]
void NoiseMapComputeShader
	(
		uint3 dispatchThreadId : SV_DispatchThreadID, 
		uint3 groupThreadId : SV_GroupThreadID, 
		uint3 groupId : SV_GroupID,
		uint GROUP_INDEX : SV_GroupIndex  // THIS IS THE ONE... An index for a specific thread group but "flattened" into a linear dimension (see notes on how this is calculated)
	)
{
    // Calculate the flattened thread ID given the current thread index of the group + the total thread-per-group factor:
	uint flattenedThreadID = GROUP_INDEX + (groupId.x * THREAD_COUNT_X);

	// Check if the current "THREAD_INDEX" has exceeded the vertex count of our map (mapChunkSize[0] * mapChunkSize[0]),
	// meaning we have exceeded the size of our heightMap buffer and we don't need to keep generating any more vertex heights
	if ( (int)flattenedThreadID < (mapChunkSize[0] * mapChunkSize[0]))
	{
		// NOTE: Hardcoding these values here for now until I decide how best to handle the inverse lerp of all the returned perlin noise values... (spoiler I might do this in the next compute shader)
		float maxNoiseHeight = 0;
		float minNoiseHeight = -5;

		float halfWidth = (float)mapChunkSize[0] / 2.0f;
		float halfHeight = (float)mapChunkSize[0] / 2.0f;

		int x = flattenedThreadID % mapChunkSize[0];
		int y = (int)floor(flattenedThreadID / mapChunkSize[0]);

		float amplitude = 1;
		float frequency = 1;
		float noiseHeight = 0;

		for (int i = 0; i < octaveCount[0]; i++)
		{
			float sampleX = (x - halfWidth) / noiseScale[0] * frequency + octaveOffsets[i].x;
			float sampleY = (y - halfHeight) / noiseScale[0] * frequency + octaveOffsets[i].y;
			float2 mapSample = float2(sampleX, sampleY);

			// float perlinValue = noise(mapSample) * 2 - 1; // we multiply by '2' then subtract '1' so that our values can be negative!!
			float perlinValue = PerlinNoise(mapSample); // we multiply by '2' then subtract '1' so that our values can be negative!!
			perlinValue = perlinValue * 2 - 1;
			noiseHeight += perlinValue * amplitude;

			amplitude *= persistance[0];  // Decreases with each octave
			frequency *= lacurnarity[0]; // multiplied by 'lacurnarity' so the frequency increases each octave (since lacurnarity is always greater than 1)
		}

		// // BIG flaw with this code; for the inverse lerp to take full effect, we need to be doing this check after we've filled the map with it's unfiltered perlin values...
		// if (noiseHeight > maxNoiseHeight)
		// {
		// 	maxNoiseHeight = noiseHeight;
		// }
		// else if (noiseHeight < minNoiseHeight)
		// {
		// 	minNoiseHeight = noiseHeight;
		// }
		noiseHeight = InverseLerp(minNoiseHeight, maxNoiseHeight, noiseHeight);


		// float original;
		// InterlockedExchange(noiseMap[THREAD_INDEX], (float)THREAD_INDEX, original);


		// noiseMap[THREAD_INDEX] = InverseLerp(minNoiseHeight, maxNoiseHeight, noiseHeight);

		// noiseMap[flattenedThreadID] = (float)flattenedThreadID;
		noiseMap[flattenedThreadID] = noiseHeight;

	}
	else
	{
		// float original;
		// InterlockedExchange(noiseMap[THREAD_INDEX], 7.2f, original);
		// noiseMap[THREAD_INDEX] = 7.2f;
	}
}


